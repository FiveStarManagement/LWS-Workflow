# services/phase2_custref_changes.py

from typing import Optional

from api import send_post_request, b64_json, decode_generic
from db import (
    get_so4_header_snapshot,
    upsert_so4_header_snapshot,
    insert_change_log,
    upsert_order_state,
    sget,
)
from logger import get_logger
from db import rquery, upsert_order_state, insert_change_log
from datetime import datetime, timezone

from config import FULFILLMENT_EMAILS
from emailer import send_email


log = get_logger("phase2_custref")

# ---------------------------------------------------------------------
# âœ… House Style Email Wrapper (match Phase2 Qty emails)
# ---------------------------------------------------------------------
def _house_email_wrap(title: str, intro_html: str, body_html: str, footer_html: str = "") -> str:
    return f"""
    <div style="font-family:Segoe UI,Arial,sans-serif; max-width:950px; margin:auto; border:1px solid #e5e7eb;
                border-radius:10px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.04);">
      <div style="background:#0f172a; padding:16px 20px;">
        <h2 style="margin:0; color:white; font-size:20px;">ðŸ“Œ {title}</h2>
      </div>
      <div style="padding:18px 20px; background:white;">
        <p style="margin:0 0 14px; font-size:14px; color:#111827;">
          {intro_html}
        </p>
        {body_html}
        <div style="margin-top:22px; font-size:12px; color:#6b7280; border-top:1px solid #e5e7eb; padding-top:12px;">
          {footer_html or "This email was automatically generated by the LWS Workflow Monitor."}
        </div>
      </div>
    </div>
    """

# ---------------------------------------------------------------------
# âœ… Dedupe: prevent sending the same fulfillment email repeatedly
# One email per (SO4, old_custref, new_custref)
# ---------------------------------------------------------------------
def _was_fulfillment_notified(sqlite_conn, so4: int, old_custref: str, new_custref: str) -> bool:
    row = sqlite_conn.execute("""
        SELECT 1
        FROM order_change_log
        WHERE so4_sordernum=?
          AND change_type='CUSTREF_FULFILLMENT_NOTIFIED'
          AND COALESCE(old_value,'')=COALESCE(?, '')
          AND COALESCE(new_value,'')=COALESCE(?, '')
        LIMIT 1
    """, (int(so4), str(old_custref or ""), str(new_custref or ""))).fetchone()
    return row is not None


def _send_fulfillment_custref_reconfirm_email(
    *,
    sqlite_conn,
    run_id: str,
    so4: int,
    so_p2: int,
    old_custref: str,
    new_custref: str,
    logger,
):
    """
    Notify fulfillment team: CustRef changed and has been synced to StarPak SO.
    Ask them to reconfirm jobs so AutoCount labels reflect the new reference.
    """

    # Pull job numbers from workflow state (best available source)
    row = sqlite_conn.execute("""
        SELECT job_p4_code, job_p2_code, po_p4_num, so_p2_num
        FROM lws_order_state
        WHERE sordernum=?
    """, (int(so4),)).fetchone()

    job_p4 = (row["job_p4_code"] if row and row["job_p4_code"] else "") if row else ""
    job_p2 = (row["job_p2_code"] if row and row["job_p2_code"] else "") if row else ""
    po_p4 = (row["po_p4_num"] if row and row["po_p4_num"] else "") if row else ""

    intro = (
        f"Line Number was updated on PolyTex Sales Order <b>{so4}</b> "
        f"and has been synced to StarPak. "
        f"Please ensure ShopFloor (AutoCount) labels reflect the updated Line Number."
    )


    body = f"""
    <div style="margin:16px 0; padding:14px; border:1px solid #fde68a; background:#fffbeb; border-radius:10px;">
      <table style="width:100%; border-collapse:collapse; font-size:14px;">
        <tr><td style="padding:6px 0; width:220px;"><b>PolyTex SO (Plant 4):</b></td><td style="padding:6px 0;">{so4}</td></tr>
        <tr><td style="padding:6px 0;"><b>PolyTex PO:</b></td><td style="padding:6px 0;">{po_p4 or "â€”"}</td></tr>
        <tr><td style="padding:6px 0;"><b>StarPak SO (Plant 2):</b></td><td style="padding:6px 0;">{so_p2}</td></tr>
        <tr><td style="padding:6px 0;"><b>Line Number (Old â†’ New):</b></td><td style="padding:6px 0;">{old_custref or "â€”"} â†’ <b>{new_custref or "â€”"}</b></td></tr>
        <tr><td style="padding:6px 0;"><b>PolyTex Job (P4):</b></td><td style="padding:6px 0;">{job_p4 or "â€”"}</td></tr>
        <tr><td style="padding:6px 0;"><b>StarPak Job (P2):</b></td><td style="padding:6px 0;">{job_p2 or "â€”"}</td></tr>
      </table>
    </div>

    <p style="margin:0; font-size:14px; color:#111827;">
      <b>Action Required:</b> Please reconfirm the jobs (PolyTex Job &amp; StarPak Job)
      so the updated Line Number is reflected on ShopFloor (AutoCount) labels.
    </p>
    """

    html = _house_email_wrap(
        title="Line Number (CustRef) Updated â€” Job Reconfirm Required",
        intro_html=intro,
        body_html=body,
        footer_html="This notification was generated automatically after a CustRef update."
    )

    subject = f"[LWS] Line Number (CustRef)  Updated â€” Reconfirm Jobs (SO4 {so4})"
    send_email(FULFILLMENT_EMAILS, subject, html)

    # record dedupe entry
    insert_change_log(
        sqlite_conn,
        run_id,
        int(so4),
        0,
        "CUSTREF_FULFILLMENT_NOTIFIED",
        old_value=str(old_custref or ""),
        new_value=str(new_custref or ""),
        details={"so_p2": int(so_p2), "note": "Fulfillment notified to reconfirm jobs for label CustRef update."},
    )

    logger.info(f"[CustRef Notify] Sent fulfillment email SO4={so4} old='{old_custref}' new='{new_custref}'")





def get_so_header_custref_p4(ro_conn, so4: int) -> str:
    sql = """
    SELECT so."CustRef"
    FROM "PUB"."PV_SOrder" so
    WHERE so."CompNum" = 2
      AND so."PlantCode" = '4'
      AND so."SOrderNum" = ?
    """
    cur = ro_conn.cursor()
    cur.execute(sql, (so4,))
    row = cur.fetchone()
    if not row:
        return ""
    return (row[0] or "").strip()

def get_so_header_custref_p2(ro_conn, so_num: int) -> str:
    sql = """
    SELECT so."CustRef"
    FROM "PUB"."PV_SOrder" so
    WHERE so."CompNum" = 2
      AND so."PlantCode" = '2'
      AND so."SOrderNum" = ?
    """
    rows = rquery(ro_conn, sql, (so_num,))
    if not rows:
        return ""
    return str(rows[0].get("CustRef") or rows[0].get("custref") or "").strip()


def update_starpak_so_custref_api(rw_conn, so_p2: int, custref: str, logger):
    """
    Minimal StarPak SO header update payload.
    Includes SOrderStat=0 to avoid credit hold bug.
    """
    payload = {
        "XLSOrders": {
            "XLSOrder": [
                {
                    "CompNum": 2,
                    "PlantCode": "2",
                    "SOrderNum": int(so_p2),
                    "SOrderStat": 0,
                    "CustRef": str(custref or "").strip()
                }
            ]
        }
    }

    resp = send_post_request("XLinkAPISOrder", b64_json(payload), logger)
    dec = decode_generic(resp)

    if dec.status_code != 1:
        raise RuntimeError(f"StarPak CustRef update failed: status={dec.status_code} messages={dec.messages}")

    return dec


def detect_so4_custref_changes_and_update_starpak(
    *,
    sqlite_conn,
    ro_conn,
    rw_conn,
    run_id: str,
    so4_sordernum: int,
    so_p2: Optional[int],
    force_authorize_func,
    logger
) -> bool:
    logger.debug(f"[Phase2 CustRef] ENTER so4={so4_sordernum} so_p2={so_p2}")
    """
    Detects Plant4 PV_SOrder.CustRef changes.
    If changed, updates StarPak SO header CustRef using minimal payload.
    âœ… DOES NOT set HOLD. Keeps order COMPLETE.
    Returns True if update was performed.
    """

    

    if not so_p2:
        return False

    # current custref from Plant4
    current_custref = get_so_header_custref_p4(ro_conn, int(so4_sordernum)) or ""

    # previous snapshot
    snap = get_so4_header_snapshot(sqlite_conn, int(so4_sordernum))
    prev_custref = (snap["custref"] if snap else "") or ""

    # âœ… NEW: Safety guard â€” prevent rapid repeated updates (double-run protection)
    snap_updated_ts = sget(snap, "updated_ts", None)
    if snap_updated_ts:
        try:
            snap_dt = datetime.fromisoformat(str(snap_updated_ts).replace("Z", "+00:00"))
            if (datetime.now(timezone.utc) - snap_dt).total_seconds() < 5:
                return False
        except Exception:
            pass


    # âœ… normalize for compare
    cur_norm = current_custref.strip()
    prev_norm = prev_custref.strip()

    # âœ… FIRST TIME SNAPSHOT missing
    if not snap:
        sp_custref = get_so_header_custref_p2(ro_conn, int(so_p2)) or ""
        sp_norm = sp_custref.strip()

        # âœ… If StarPak differs, sync it once
        if sp_norm != cur_norm:
            logger.info(
                f"[Phase2 CustRef] FIRST SNAPSHOT â†’ syncing StarPak CustRef '{sp_norm}' -> '{cur_norm}' (SO_P2={so_p2})"
            )

            update_starpak_so_custref_api(rw_conn, int(so_p2), cur_norm, logger)
            force_authorize_func(rw_conn, int(so_p2), logger)

            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                0,
                "CUSTREF_SYNCED_NO_SNAPSHOT",
                old_value=sp_norm,
                new_value=cur_norm,
                details={"so_p2": int(so_p2)},
            )

            # âœ… Notify fulfillment (deduped)
            if not _was_fulfillment_notified(sqlite_conn, int(so4_sordernum), sp_norm, cur_norm):
                _send_fulfillment_custref_reconfirm_email(
                    sqlite_conn=sqlite_conn,
                    run_id=run_id,
                    so4=int(so4_sordernum),
                    so_p2=int(so_p2),
                    old_custref=sp_norm,
                    new_custref=cur_norm,
                    logger=logger,
                )




        # âœ… baseline snapshot and STOP (no change detection on same run)
        upsert_so4_header_snapshot(sqlite_conn, int(so4_sordernum), cur_norm)
        return True if sp_norm != cur_norm else False

    # âœ… no change
    if cur_norm == prev_norm:
        return False

    # âœ… change detected
    logger.info(
        f"[Phase2 CustRef] SO4={so4_sordernum} CustRef changed '{prev_norm}' -> '{cur_norm}' (SO_P2={so_p2})"
    )

    # update StarPak header
    update_starpak_so_custref_api(rw_conn, int(so_p2), cur_norm, logger)

    # force authorize after header touch
    force_authorize_func(rw_conn, int(so_p2), logger)

    # change log entry
    insert_change_log(
        sqlite_conn,
        run_id,
        int(so4_sordernum),
        0,
        "CUSTREF_CHANGED",
        old_value=prev_norm,
        new_value=cur_norm,
        details={"so_p2": int(so_p2)},
    )

    # âœ… Notify fulfillment (deduped)
    if not _was_fulfillment_notified(sqlite_conn, int(so4_sordernum), prev_norm, cur_norm):
        _send_fulfillment_custref_reconfirm_email(
            sqlite_conn=sqlite_conn,
            run_id=run_id,
            so4=int(so4_sordernum),
            so_p2=int(so_p2),
            old_custref=prev_norm,
            new_custref=cur_norm,
            logger=logger,
        )




    # update snapshot
    upsert_so4_header_snapshot(sqlite_conn, int(so4_sordernum), cur_norm)

    # âœ… Do NOT overwrite HOLD status/step â€” only update admin if current status is COMPLETE
    state = sqlite_conn.execute(
        "SELECT status FROM lws_order_state WHERE sordernum=?",
        (int(so4_sordernum),)
    ).fetchone()

    current_status = (state["status"] if state else "").upper()

    if current_status == "COMPLETE":
        upsert_order_state(
            sordernum=int(so4_sordernum),
            status="COMPLETE",
            last_step="SO4_CUSTREF_UPDATED_STARPAK",
            last_run_id=run_id,
            last_error_summary=f"CustRef updated on PolyTex SO. StarPak SO {so_p2} header updated.",
            so_p2=int(so_p2),
        )

    return True
