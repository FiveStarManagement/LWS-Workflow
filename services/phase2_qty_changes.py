# services/phase2_qty_changes.py
#
# Phase 2 implementation:
#  - Phase 2A: Detect Plant 4 SO qty change vs snapshot => email CSR, HOLD (no downstream updates)
#  - Phase 2B: After PolyTex reconfirm (PV_Req change) => update PolyTex PO via API JSON,
#              update StarPak SO line qty via API JSON, email StarPak to reconfirm job, HOLD
#  - Phase 2C: Detect StarPak reconfirm (Plant 2 PV_Req change) => refresh snapshots, set COMPLETE
#
# IMPORTANT GUARDRAILS:
#  - HOLD ‚â† FAIL
#  - Do NOT let Phase 1 mark COMPLETE while in Phase 2 HOLD (enforced in app.py filtering)
#  - Do NOT overwrite SO4 snapshot on detection; refresh snapshots only when we return to COMPLETE.
#
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from config import CSR_EMAILS, STARPAK_EMAILS, FULFILLMENT_EMAILS
from emailer import send_email
from exceptions import WorkflowHold

from db import sget


from db import (
    get_so4_line_snapshot,
    upsert_so4_line_snapshot,

    # old RequirementId snapshot still used by Phase2C (Plant2) if you want,
    # but Phase2B must use keyed snapshot
    get_req_snapshot,
    upsert_req_snapshot,

    # ‚úÖ NEW keyed snapshot (Phase2B fix)
    get_req_snapshot_keyed,
    upsert_req_snapshot_keyed,

    get_po_map,
    insert_change_log,
    upsert_order_state,
    rquery,
    mark_run_order,
)


from services.starpak_so import find_existing_so_by_po, get_jobline_qty_p2, get_so_line_qty_p2


# ------------------------------------------------------------
# ‚úÖ StarPak API touches (create/update) often set SO to Credit Held.
# This helper forces StarPak SO back to AUTHORIZED (sorderstat = 0).
# ------------------------------------------------------------
def force_starpak_so_authorized(rw_conn, so_num: int, logger):
    sql = """
    UPDATE pub.pv_sorder
       SET sorderstat = 0
     WHERE compnum = 2
       AND plantcode = '2'
       AND sordernum = ?
    """
    cur = rw_conn.cursor()
    cur.execute(sql, (int(so_num),))
    rw_conn.commit()
    logger.info(f"[Phase2B FIX] Forced StarPak SO {so_num} back to AUTHORIZED (sorderstat=0).")


# NOTE:
# You said "all qty changes should happen by sending new JSON payload".
# That means polytex_po_update.py MUST expose API-based functions.
# If your current file still uses SQL update, replace it with API calls.
try:
    # expected new functions (API JSON)
    from services.polytex_po_update import update_po_line_qty_api, update_so_line_qty_api
except Exception:  # pragma: no cover
    update_po_line_qty_api = None
    update_so_line_qty_api = None


# If STARPAK_EMAILS isn't in config yet, fall back to CSR_EMAILS to avoid crashing.
try:
    from config import STARPAK_EMAILS  # type: ignore
except Exception:  # pragma: no cover
    STARPAK_EMAILS = CSR_EMAILS


PO_BLOCK_STATUSES = {8, 9}  # Complete, Cancelled

# ---------------------------------------------------------------------
# ‚úÖ House Style Email Wrapper (used by all workflow emails)
# ---------------------------------------------------------------------
def _house_email_wrap(title: str, intro_html: str, body_html: str, footer_html: str = "") -> str:
    """
    Returns professional consistent HTML email wrapper.
    """
    return f"""
    <div style="font-family:Segoe UI,Arial,sans-serif; max-width:950px; margin:auto; border:1px solid #e5e7eb;
                border-radius:10px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.04);">

      <!-- Header -->
      <div style="background:#0f172a; padding:16px 20px;">
        <h2 style="margin:0; color:white; font-size:20px;">üìå {title}</h2>
      </div>

      <!-- Body -->
      <div style="padding:18px 20px; background:white;">
        <p style="margin:0 0 14px; font-size:14px; color:#111827;">
          {intro_html}
        </p>

        {body_html}

        <div style="margin-top:22px; font-size:12px; color:#6b7280; border-top:1px solid #e5e7eb; padding-top:12px;">
          {footer_html or "This email was automatically generated by the LWS Workflow Monitor."}
        </div>
      </div>

    </div>
    """

# qty reduce changes
def get_latest_so_qty_change(sqlite_conn, so4_sordernum: int):
    """
    Returns (old_qty, new_qty, created_ts) for the most recent PT SO qty change.
    Uses order_change_log as source of truth.
    """
    cur = sqlite_conn.cursor()
    cur.execute(
        """
        SELECT old_value, new_value, created_ts
          FROM order_change_log
         WHERE so4_sordernum = ?
           AND change_type = 'SO_QTY_CHANGED'
         ORDER BY id DESC
         LIMIT 1
        """,
        (int(so4_sordernum),),
    )
    row = cur.fetchone()
    if not row:
        return None, None, None

    try:
        old_qty = float(row[0]) if row[0] is not None else None
    except Exception:
        old_qty = None

    try:
        new_qty = float(row[1]) if row[1] is not None else None
    except Exception:
        new_qty = None

    return old_qty, new_qty, row[2]

# ---------------------------------------------------------------------
# SQLite helpers (local queries). Keeps Phase2 idempotent without
# requiring new db.py functions.
# ---------------------------------------------------------------------


def _row_get(row, key: str, default=None):
    """
    Works for dict, sqlite3.Row, and tuple-ish rows.
    """
    if row is None:
        return default

    # dict
    if isinstance(row, dict):
        return row.get(key, default)

    # sqlite3.Row supports "in" and ["col"]
    try:
        if key in row.keys():
            v = row[key]
            return default if v is None else v
    except Exception:
        pass

    # fallback: try attribute
    try:
        v = getattr(row, key)
        return default if v is None else v
    except Exception:
        return default



def _already_logged_change(
    sqlite_conn,
    sordernum: int,
    line_num: int,
    change_type: str,
    new_value: Optional[float],
    logger=None,
) -> bool:
    """
    Return True if order_change_log already has this change_type for this order/line and new_value.
    Uses numeric compare for new_value to avoid '7700' vs '7700.0' string mismatch.
    """
    try:
        cur = sqlite_conn.cursor()

        if new_value is None:
            cur.execute(
                """
                SELECT 1
                  FROM order_change_log
                 WHERE so4_sordernum = ?
                   AND so4_linenum   = ?
                   AND change_type   = ?
                   AND new_value IS NULL
                 LIMIT 1
                """,
                (int(sordernum), int(line_num), str(change_type)),
            )
        else:
            cur.execute(
                """
                SELECT 1
                  FROM order_change_log
                 WHERE so4_sordernum = ?
                   AND so4_linenum   = ?
                   AND change_type   = ?
                   AND CAST(new_value AS REAL) = ?
                 LIMIT 1
                """,
                (int(sordernum), int(line_num), str(change_type), float(new_value)),
            )

        return cur.fetchone() is not None

    except Exception as e:
        if logger:
            logger.warning(f"_already_logged_change failed: {e}")
        return False


def get_p4_film_requirements(ro_conn, jobcode: str):
    """
    Film/substrate requirements for Plant 4 job.
    Filters to active/unreserved req rows to avoid noise and closed/consumed rows.
    """
    sql = """
    SELECT
        a."RequirementId" AS RequirementId,
        a."JobCode"       AS JobCode,
        a."ItemCode"      AS ItemCode,
        a."RequiredQty"   AS RequiredQty,
        a."RequiredDate"  AS RequiredDate,
        a."ReqStatus"     AS ReqStatus,
        a."ReqGroupCode"  AS ReqGroupCode,
        a."POResQty"      AS POResQty,
        a."InProdResQty"  AS InProdResQty,
        a."SOrderNum"     AS SOrderNum,
        a."SOrderLineNum" AS SOrderLineNum,
        a."DimA"          AS DimA
    FROM "PUB"."PV_Req" a
    WHERE a."CompNum" = 2
      AND a."PlantCode" = '4'
      AND a."JobCode" = ?
      AND a."ReqGroupCode" IN ('P4-PF','P4-FILM')
      AND a.ItemCode LIKE '16P4-%'
      AND a."ReqStatus" IN (10, 11, 20, 21)
      AND COALESCE(a."POResQty",0) < 1
      AND COALESCE(a."InProdResQty",0) < 1
      AND a."RequiredQty" > 0
    ORDER BY a."RequiredDate" ASC
    """
    return rquery(ro_conn, sql, (str(jobcode),))




def _get_state_fields(sqlite_conn, sordernum: int) -> Dict[str, Any]:
    """
    Reads useful fields from lws_order_state safely.
    Uses the real column names from your DB schema.
    """
    cur = sqlite_conn.cursor()
    cur.execute(
        """
        SELECT
            sordernum,
            status,
            last_step,
            po_p4_num,
            so_p2_num,
            shipreq_p2,
            job_p2_code,
            job_p4_code
        FROM lws_order_state
        WHERE sordernum = ?
        """,
        (int(sordernum),),
    )

    row = cur.fetchone()
    if not row:
        return {}

    return {
        "sordernum": row[0],
        "status": row[1],
        "last_step": row[2],
        "po_p4": row[3],   # Normalize into po_p4
        "so_p2": row[4],
        "shipreq_p2": row[5],   
        "job_p2": row[6],
        "job_p4": row[7],
    }


# ---------------------------------------------------------------------
# Radius helpers
# ---------------------------------------------------------------------
def get_po_line_info(ro_conn, po_num: int, po_linenum: int = 1) -> Optional[Dict[str, Any]]:
    sql = """
    SELECT
        p.porderstat AS porderstat,
        pl.pordernum AS pordernum,
        pl.porderlinenum AS porderlinenum,
        pl.orderedqty AS orderedqty,
        pl.receivedqty AS receivedqty,
        pl.itemcode AS itemcode,
        pl.plantcode AS plantcode
    FROM PUB.PV_POrder p
    JOIN PUB.PV_POrderLine pl
      ON p.compnum = pl.compnum
     AND p.pordernum = pl.pordernum
    WHERE p.compnum = 2
      AND p.pordernum = ?
      AND pl.porderlinenum = ?
    """
    rows = rquery(ro_conn, sql, (int(po_num), int(po_linenum)))
    return rows[0] if rows else None


def get_so_line_info_p2(ro_conn, so_num: int, so_linenum: int = 1) -> Optional[Dict[str, Any]]:
    sql = """
    SELECT
        sol.sordernum AS sordernum,
        sol.sorderlinenum AS sorderlinenum,
        sol.itemcode AS itemcode,
        sol.orderedqty AS orderedqty,
        sol.reqdate AS reqdate
    FROM PUB.PV_SOrderLine sol
    WHERE sol.compnum = 2
      AND sol.plantcode = '2'
      AND sol.sordernum = ?
      AND sol.sorderlinenum = ?
    """
    rows = rquery(ro_conn, sql, (int(so_num), int(so_linenum)))
    return rows[0] if rows else None


def get_job_requirements_by_jobcode(ro_conn, plantcode: str, jobcode: str) -> List[Dict[str, Any]]:
    """
    Generic PV_Req fetch by jobcode and plantcode. We keep it broad but safe.
    You can tighten ReqGroupCode/ReqStatus later if needed.
    """
    sql = """
    SELECT
        a.RequirementId AS RequirementId,
        a.JobCode       AS JobCode,
        a.ItemCode      AS ItemCode,
        a.RequiredQty   AS RequiredQty,
        a.RequiredDate  AS RequiredDate,
        a.ReqStatus     AS ReqStatus,
        a.ReqGroupCode  AS ReqGroupCode,
        a.SOrderNum     AS SOrderNum,
        a.SOrderLineNum AS SOrderLineNum
    FROM PUB.PV_Req a
    WHERE a.CompNum = 2
      AND a.PlantCode = ?
      AND a.JobCode = ?
      AND a.RequiredQty > 0
    ORDER BY a.RequiredDate ASC
    """
    return rquery(ro_conn, sql, (str(plantcode), str(jobcode)))

def get_so_lines_p4(ro_conn, sordernum: int) -> list[dict]:
    """
    Fetch Plant4 SO lines (source of truth for ordered qty snapshot).
    Used only to refresh snapshot baseline after Phase2C completes.
    """
    sql = """
    SELECT sol."SOrderLineNum", sol."ItemCode", sol."OrderedQty", sol."ReqDate"
    FROM "PUB"."PV_SOrderLine" sol
    WHERE sol."CompNum" = 2
      AND sol."PlantCode" = '4'
      AND sol."SOrderNum" = ?
    ORDER BY sol."SOrderLineNum"
    """
    return rquery(ro_conn, sql, (int(sordernum),))


# ---------------------------------------------------------------------
# Phase 2A - Detect Plant4 SO OrderedQty changes
# ---------------------------------------------------------------------
def detect_so4_qty_changes_or_hold(
    sqlite_conn,
    run_id: str,
    so4_sordernum: int,
    so_lines: List[Dict[str, Any]],
    logger,
) -> None:
    """
    Source of truth for detecting change = Plant4 SO line OrderedQty.
    If any line qty changed vs last snapshot:
      - log change (once per new qty)
      - email CSR (once per new qty)
      - set state HOLD / SO4_QTY_CHANGED_WAIT_RECONFIRM
      - raise WorkflowHold
    """
    changed_lines: List[Tuple[int, str, float, float]] = []

    for ln in so_lines:
        line_num = int(ln.get("SOrderLineNum") or ln.get("sorderlinenum") or 0)
        itemcode = str(ln.get("ItemCode") or ln.get("itemcode") or "").strip()
        orderedqty = float(ln.get("OrderedQty") or ln.get("orderedqty") or 0.0)
        reqdate = str(ln.get("ReqDate") or ln.get("reqdate") or "")[:10]

        if not line_num:
            continue

        snap = get_so4_line_snapshot(sqlite_conn, int(so4_sordernum), int(line_num))

        # First time: store snapshot only, no hold
        if not snap:
            upsert_so4_line_snapshot(sqlite_conn, int(so4_sordernum), int(line_num), itemcode, orderedqty, reqdate)
            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                int(line_num),
                "SO_SNAPSHOT_CREATED",
                None,
                orderedqty,
                details={"itemcode": itemcode},
            )
            continue

        old_qty = float(_row_get(snap, "orderedqty", 0.0) or 0.0)

        if old_qty != orderedqty:
            changed_lines.append((line_num, itemcode, old_qty, orderedqty))

    if not changed_lines:
        return

    # Log + email (idempotent per new_qty)
    new_events: List[Tuple[int, str, float, float]] = []
    for (line_num, itemcode, old_qty, new_qty) in changed_lines:
        if _already_logged_change(sqlite_conn, int(so4_sordernum), int(line_num), "SO_QTY_CHANGED", float(new_qty)):
            continue
        insert_change_log(
            sqlite_conn,
            run_id,
            int(so4_sordernum),
            int(line_num),
            "SO_QTY_CHANGED",
            float(old_qty),
            float(new_qty),
            details={"itemcode": itemcode},
        )
        new_events.append((line_num, itemcode, old_qty, new_qty))

    if new_events:
        body = "<br>".join(
            [
                f"SO {so4_sordernum} line {ln}: {old} ‚Üí {new} (Item: {it})"
                for (ln, it, old, new) in new_events
            ]
        )
        body_html = f"""
        <div style="margin:16px 0; padding:14px; border:1px solid #f3f4f6; background:#f9fafb; border-radius:10px;">
        <h3 style="margin:0 0 10px; font-size:15px; color:#111827;">üìå Quantity Change Details</h3>
        <p style="margin:0; font-size:14px; color:#111827;">
            {body}
        </p>
        </div>

        <div style="margin-top:16px;">
        <p style="margin:0; font-size:14px; color:#111827;">
            ‚úÖ <b>Next Step:</b> Please update the production estimate and reconfirm the PolyTex Job in Radius.
        </p>
        </div>
        """

        html = _house_email_wrap(
            title="PolyTex SO Quantity Changed",
            intro_html=f"The PolyTex Sales Order quantity changed. Radius requirements (PV_Req) will not update until the job is manually reconfirmed.",
            body_html=body_html,
            footer_html=f"Once reconfirmed, the workflow will automatically detect PV_Req changes and update downstream orders where allowed."
        )

        send_email(CSR_EMAILS, f"PolyTex SO {so4_sordernum} qty changed ‚Äì reconfirm job required", html)
        logger.info(f"Phase2A: emailed CSR for SO {so4_sordernum} qty change.")

    # HOLD state (do not touch snapshots yet)
    upsert_order_state(
        sordernum=int(so4_sordernum),
        status="HOLD",
        last_step="SO4_QTY_CHANGED_WAIT_RECONFIRM",
        last_run_id=run_id,
        last_error_summary="SO line qty changed ‚Äì waiting for manual job reconfirm (PV_Req update).",
    )
    raise WorkflowHold("SO line qty changed ‚Äì waiting for manual job reconfirm (PV_Req update).")


# ---------------------------------------------------------------------
# Phase 2B - Apply PV_Req changes to PO + StarPak SO after reconfirm
# ---------------------------------------------------------------------
def apply_req_changes_to_po(
    sqlite_conn,
    ro_conn,
    rw_conn,  # unused when using API, kept for signature compatibility
    run_id: str,
    so4_sordernum: int,
    job_p4: str,
    reqs: List[Dict[str, Any]],
    logger,
) -> bool:
    """
    Uses PV_Req.RequiredQty as the source for downstream qty (FEET).
    Only applies when PV_Req changed vs last snapshot (meaning reconfirm happened).

    Phase 2B actions for each changed req:
      - validate PO can be updated (not received/closed)
      - update PolyTex PO via API JSON
      - update StarPak SO line qty via API JSON
      - email StarPak reconfirm request
      - set order HOLD / P2_SO_QTY_UPDATED_WAIT_RECONFIRM
    """
    if update_po_line_qty_api is None or update_so_line_qty_api is None:
        raise RuntimeError(
            "Missing API update functions. Update services/polytex_po_update.py to expose "
            "update_po_line_qty_api() and update_so_line_qty_api()."
        )

    any_change = False

    for r in reqs:
        
# ============================================================
# Phase2B (inside apply_req_changes_to_po loop: for r in reqs:)
# REPLACE your entire shown block with this corrected block
# ============================================================

        # --------------------------------------------------
        # üîí Phase 2B GUARD: only substrate material reqs
        # --------------------------------------------------
        item = str(r.get("ItemCode") or r.get("ITEMCODE") or r.get("itemcode") or "").strip().upper()
        if not item.startswith("16P4-"):
            continue

        reqgroup = str(r.get("ReqGroupCode") or r.get("REQGROUPCODE") or r.get("reqgroupcode") or "").strip().upper()
        if reqgroup not in ("P4-FILM", "P4-PF"):
            continue

        requiredqty = float(r.get("RequiredQty") or r.get("REQUIREDQTY") or r.get("requiredqty") or 0.0)
        requireddate = str(r.get("RequiredDate") or r.get("REQUIREDDATE") or r.get("requireddate") or "")[:10]

        # RequirementId is NOT stable after reconfirm ‚Äî only use for logging if present
        req_id = (
            r.get("RequirementId")
            or r.get("RequirementID")
            or r.get("REQUIREMENTID")
            or r.get("requirementid")
        )
        req_id = int(req_id) if req_id is not None else None

        snap = get_req_snapshot_keyed(sqlite_conn, str(job_p4), reqgroup, item)

        # First time snapshot:
        # IMPORTANT: If we're already in SO4_QTY_CHANGED_WAIT_RECONFIRM, do NOT seed baseline
        # from PV_Req (it might already reflect reconfirm). Instead seed from current downstream PO qty
        # so Phase2B can detect the "catch-up" delta safely.
        if not snap:
            baseline_qty = float(requiredqty)   # default fallback
            baseline_src = "pvreq"

            # Determine current workflow step
            try:
                st0 = _get_state_fields(sqlite_conn, int(so4_sordernum))
                current_step0 = (st0.get("last_step") if st0 else "") or ""
            except Exception:
                current_step0 = ""

            if current_step0 == "SO4_QTY_CHANGED_WAIT_RECONFIRM":
                # Use SO4 line from req row if available; otherwise line 1
                so4_line0 = int(
                    r.get("SOrderLineNum")
                    or r.get("SORDERLINENUM")
                    or r.get("sorderlinenum")
                    or 1
                )

                m0 = get_po_map(sqlite_conn, int(so4_sordernum), int(so4_line0))
                if m0:
                    po_num0 = int(m0["po_num"])
                    po_linenum0 = int(m0["po_linenum"])
                    info0 = get_po_line_info(ro_conn, po_num0, po_linenum0)
                    if info0 and info0.get("orderedqty") is not None:
                        baseline_qty = float(info0.get("orderedqty") or 0.0)
                        baseline_src = f"po:{po_num0}/{po_linenum0}"

            upsert_req_snapshot_keyed(
                sqlite_conn,
                str(job_p4),
                reqgroup,
                item,
                baseline_qty,
                requireddate
            )

            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                0,
                "REQ_KEYED_SNAPSHOT_CREATED",
                None,
                baseline_qty,
                details={
                    "job_p4": str(job_p4),
                    "reqgroup": reqgroup,
                    "itemcode": item,
                    "requirement_id": req_id,
                    "baseline_source": baseline_src,
                    "pvreq_qty_at_create": float(requiredqty),
                },
            )
            continue



        old_qty = float(_row_get(snap, "requiredqty", 0.0) or 0.0)
        pvreq_changed = abs(old_qty - float(requiredqty)) > 0.0001  # tolerate float noise

        # ------------------------------------------------------------
        # ‚úÖ HARD GATE (REQUIREMENT)
        # If we're still waiting for PolyTex reconfirm, we must NOT proceed
        # until PV_Req.RequiredQty actually changes.
        # ------------------------------------------------------------
        try:
            st = _get_state_fields(sqlite_conn, int(so4_sordernum))
            current_step = (st.get("last_step") if st else "") or ""
        except Exception:
            current_step = ""

        if current_step == "SO4_QTY_CHANGED_WAIT_RECONFIRM" and not pvreq_changed:
            logger.info(
                f"[Phase2B] WAITING_POLYTEX_RECONFIRM: so4={so4_sordernum} job={job_p4} "
                f"item={item} reqgroup={reqgroup} snapshot_qty={old_qty} pvreq_qty={requiredqty} "
                f"(PV_Req unchanged; skipping Phase2B)"
            )
            continue

        # ------------------------------------------------------------
        # ‚úÖ THIS FLOW: no catch-up logic
        # Only act when PV_Req actually changed vs snapshot (i.e., reconfirm happened)
        # ------------------------------------------------------------
        if not pvreq_changed:
            continue

        # ------------------------------------------------------------
        # ‚úÖ Decrease/increase based on PV_Req change (printed material)
        # ------------------------------------------------------------
        is_decrease = float(requiredqty) < float(old_qty)

        # ‚úÖ Downstream target qty ALWAYS comes from PV_Req.RequiredQty (16P4 printed material)
        target_qty = float(requiredqty)

        # Optional: keep PT SO qty change only for logging context
        pt_old_qty, pt_new_qty, pt_changed_ts = get_latest_so_qty_change(sqlite_conn, int(so4_sordernum))

        logger.info(
            f"[Phase2B] CHANGE DETECTED so4={so4_sordernum} job={job_p4} item={item} reqgroup={reqgroup} "
            f"snapshot_qty={old_qty} pvreq_qty={requiredqty} target_qty={target_qty} "
            f"pt_old_qty={pt_old_qty} pt_new_qty={pt_new_qty} is_decrease={is_decrease}"
        )

        any_change = True

        # ‚úÖ Log REQ_QTY_CHANGED once per new pvreq qty
        if not _already_logged_change(sqlite_conn, int(so4_sordernum), 0, "REQ_QTY_CHANGED", float(requiredqty)):
            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                0,
                "REQ_QTY_CHANGED",
                float(old_qty),
                float(requiredqty),
                details={"requirement_id": req_id, "job_p4": str(job_p4)},
            )

        # ------------------------------------------------------------
        # Mapping: single-line only (for now)
        # ------------------------------------------------------------
        so4_line = int(r.get("SOrderLineNum") or r.get("SORDERLINENUM") or r.get("sorderlinenum") or 1)
        logger.info(f"[Phase2B DEBUG] looking up mapping so4={so4_sordernum} so4_line={so4_line}")

        m = get_po_map(sqlite_conn, int(so4_sordernum), int(so4_line))
        logger.info(f"[Phase2B DEBUG] mapping result so4={so4_sordernum} map={m}")

        if not m:
            body_html = f"""
            <div style="margin:16px 0; padding:14px; border:1px solid #f3f4f6; background:#f9fafb; border-radius:10px;">
            <table style="width:100%; border-collapse:collapse; font-size:14px;">
                <tr><td style="padding:6px 0; width:180px;"><b>PolyTex SO:</b></td><td style="padding:6px 0;">{so4_sordernum}</td></tr>
                <tr><td style="padding:6px 0;"><b>PV_Req Qty:</b></td><td style="padding:6px 0;">{requiredqty}</td></tr>
                <tr><td style="padding:6px 0;"><b>Target Qty:</b></td><td style="padding:6px 0;">{target_qty}</td></tr>
            </table>
            </div>

            <p style="margin:0; font-size:14px; color:#111827;">
            ‚ö†Ô∏è The workflow detected a requirement quantity change / catch-up condition, but could not find a saved mapping between the PolyTex SO line and the downstream PO line.
            </p>

            <p style="margin:14px 0 0; font-size:14px; color:#111827;">
            ‚úÖ <b>Action Required:</b> Please verify mapping logic or recreate the workflow so the SO ‚Üí PO mapping is captured.
            </p>
            """

            html = _house_email_wrap(
                title="Workflow Issue ‚Äì Missing SO ‚Üí PO Mapping",
                intro_html="A PolyTex reconfirmation/catch-up condition was detected but mapping was missing for downstream updates.",
                body_html=body_html,
                footer_html="This item will remain monitored until the mapping is available or the workflow is restarted.",
            )
            send_email(CSR_EMAILS, f"SO {so4_sordernum} PV_Req changed ‚Äì mapping missing", html)

            # Do not spam forever: update req snapshot baseline now that we processed detection
            upsert_req_snapshot_keyed(sqlite_conn, str(job_p4), reqgroup, item, requiredqty, requireddate)
            continue

        po_num = int(m["po_num"])
        po_linenum = int(m["po_linenum"])

        # ------------------------------------------------------------
        # 1) Update PT PO to PV_Req qty (this is allowed both for increase/decrease)
        # ------------------------------------------------------------
        info = get_po_line_info(ro_conn, po_num, po_linenum)
        if not info:
            upsert_req_snapshot_keyed(sqlite_conn, str(job_p4), reqgroup, item, requiredqty, requireddate)
            continue

        pstat = int(info.get("porderstat") or 0)
        received = float(info.get("receivedqty") or 0.0)
        po_old_qty = float(info.get("orderedqty") or 0.0)
        po_itemcode = str(info.get("itemcode") or "").strip()
        po_plantcode = str(info.get("plantcode") or "4").strip()

        if pstat in PO_BLOCK_STATUSES or received > 0:
            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                1,
                "PO_BLOCKED",
                po_old_qty,
                float(requiredqty),
                details={"po_num": po_num, "po_linenum": po_linenum, "porderstat": pstat, "receivedqty": received},
            )

            body_html = f"""
            <div style="margin:16px 0; padding:14px; border:1px solid #f3f4f6; background:#f9fafb; border-radius:10px;">
            <table style="width:100%; border-collapse:collapse; font-size:14px;">
            <tr><td style="padding:6px 0; width:180px;"><b>PolyTex SO:</b></td><td style="padding:6px 0;">{so4_sordernum}</td></tr>
            <tr><td style="padding:6px 0;"><b>PolyTex PO:</b></td><td style="padding:6px 0;">{po_num} (Line {po_linenum})</td></tr>
            <tr><td style="padding:6px 0;"><b>PO Status:</b></td><td style="padding:6px 0;">{pstat}</td></tr>
            <tr><td style="padding:6px 0;"><b>Received Qty:</b></td><td style="padding:6px 0;">{received}</td></tr>
            <tr><td style="padding:6px 0;"><b>PV_Req Qty:</b></td><td style="padding:6px 0;">{requiredqty}</td></tr>
            <tr><td style="padding:6px 0;"><b>Target Qty:</b></td><td style="padding:6px 0;">{target_qty}</td></tr>
            </table>
            </div>

            <p style="margin:0; font-size:14px; color:#111827;">
            ‚ö†Ô∏è The workflow cannot update the PolyTex PO because it is already received or closed.
            </p>
            """

            html = _house_email_wrap(
                title="Update Blocked ‚Äì PO Cannot Be Updated",
                intro_html="A requirement change occurred, but downstream updates were blocked due to PO status/receipts.",
                body_html=body_html,
                footer_html="The workflow will not retry this update automatically to avoid repeated alerts.",
            )

            send_email(CSR_EMAILS, f"SO {so4_sordernum} qty change ‚Äì PO {po_num} cannot be updated", html)

            # Update req snapshot baseline so we don't re-alert forever
            upsert_req_snapshot_keyed(sqlite_conn, str(job_p4), reqgroup, item, requiredqty, requireddate)
            continue

        if abs(po_old_qty - float(requiredqty)) <= 0.0001:
            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                1,
                "PO_NOOP_ALREADY_MATCHED",
                po_old_qty,
                float(requiredqty),
                details={"po_num": po_num, "po_linenum": po_linenum},
            )
        else:
            resp_po = update_po_line_qty_api(
                po_num=po_num,
                itemcode=po_itemcode,
                plantcode=po_plantcode,
                po_linenum=po_linenum,
                new_qty=float(requiredqty),
            )

            if not resp_po or resp_po.get("ok") is False:
                insert_change_log(
                    sqlite_conn,
                    run_id,
                    int(so4_sordernum),
                    1,
                    "PO_UPDATE_FAILED",
                    po_old_qty,
                    float(requiredqty),
                    details={
                        "po_num": po_num,
                        "po_linenum": po_linenum,
                        "api_entity": resp_po.get("entityName") if isinstance(resp_po, dict) else "XLinkAPIPOrder",
                        "api_http_status": resp_po.get("http_status") if isinstance(resp_po, dict) else None,
                        "api_error": resp_po.get("errorMessage") if isinstance(resp_po, dict) else "No response dict",
                        "raw_response": (resp_po.get("raw_response") if isinstance(resp_po, dict) else "") or "",
                    },
                )
                raise WorkflowHold(
                    f"Phase2B: PO update API failed for PO {po_num} line {po_linenum} "
                    f"status={resp_po.get('http_status')} err={resp_po.get('errorMessage')}"
                )

            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                1,
                "PO_UPDATED",
                po_old_qty,
                float(requiredqty),
                details={
                    "po_num": po_num,
                    "po_linenum": po_linenum,
                    "api_entity": resp_po.get("entityName"),
                    "api_http_status": resp_po.get("http_status"),
                    "api_error": resp_po.get("errorMessage") or "",
                },
            )
            logger.info(f"Phase2B: PO {po_num} line {po_linenum} updated to {requiredqty}.")

        # ------------------------------------------------------------
        # 2) Resolve StarPak SO (needed for both flows)
        # ------------------------------------------------------------
        so_num = find_existing_so_by_po(ro_conn, po_num)
        if not so_num:
            raise WorkflowHold(f"Phase2B: Cannot find StarPak SO for PO {po_num}.")

        so_num = int(so_num)
        so_line = get_so_line_info_p2(ro_conn, so_num, 1)
        if not so_line:
            raise WorkflowHold(f"Phase2B: Cannot find StarPak SO {so_num} line 1.")

        so_old_qty = float(so_line.get("orderedqty") or 0.0)
        so_itemcode = str(so_line.get("itemcode") or "").strip()
        so_reqdate = requireddate or (str(so_line.get("reqdate") or "")[:10] or "")

        # ------------------------------------------------------------
        # ‚úÖ DECREASE FLOW:
        # - DO NOT update StarPak SO/ShipReq now (Radius reserved qty rule)
        # - Send Fulfillment email: update estimate + reconfirm SP job
        # - HOLD in P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM
        # - Phase2C will update SO+ShipReq after job reconfirm
        # ------------------------------------------------------------
        if is_decrease:
            # best-effort: fetch job_p2 from state (already stored during Phase1)
            try:
                st = _get_state_fields(sqlite_conn, int(so4_sordernum))
                job_p2 = st.get("job_p2") if st else None
            except Exception:
                job_p2 = None

            # Send Fulfillment decrease email (idempotent per target_qty)
            if not _already_logged_change(sqlite_conn, int(so4_sordernum), 1, "FULFILLMENT_DECREASE_EMAIL_SENT", float(target_qty)):
                body_html = f"""
                <div style="margin:16px 0; padding:14px; border:1px solid #f3f4f6; background:#f9fafb; border-radius:10px;">
                <h3 style="margin:0 0 10px; font-size:15px; color:#111827;">üìå Quantity Decreased ‚Äì Action Required</h3>
                <table style="width:100%; border-collapse:collapse; font-size:14px;">
                    <tr><td style="padding:6px 0; width:180px;"><b>PolyTex SO:</b></td><td style="padding:6px 0;">{so4_sordernum}</td></tr>
                    <tr><td style="padding:6px 0;"><b>PolyTex PO:</b></td><td style="padding:6px 0;">{po_num} (Line {po_linenum})</td></tr>
                    <tr><td style="padding:6px 0;"><b>StarPak SO:</b></td><td style="padding:6px 0;">{so_num}</td></tr>
                    <tr><td style="padding:6px 0;"><b>StarPak Job:</b></td><td style="padding:6px 0;">{job_p2 or "‚Äî"}</td></tr>
                    <tr><td style="padding:6px 0;"><b>Old Qty:</b></td><td style="padding:6px 0;">{old_qty}</td></tr>
                    <tr><td style="padding:6px 0;"><b>New Qty:</b></td><td style="padding:6px 0;">{target_qty}</td></tr>
                </table>
                </div>

                <p style="margin:0; font-size:14px; color:#111827;">
                ‚ö†Ô∏è <b>Note:</b> Radius may reject decreasing the StarPak SO line qty while reserved qty exists
                (example error: ‚ÄúOrdered qty cannot be less than reserved quantity‚Äù).
                </p>

                <p style="margin:14px 0 0; font-size:14px; color:#111827;">
                ‚úÖ <b>Next Step (Fulfillment):</b><br>
                1) Update the <b>StarPak Production Estimate</b> for job <b>{job_p2 or "‚Äî"}</b> to qty <b>{target_qty}</b><br>
                2) <b>Reconfirm the StarPak Job</b> in Radius<br>
                </p>

                <p style="margin:14px 0 0; font-size:14px; color:#111827;">
                After reconfirmation, the automation will update the <b>StarPak SO line qty</b> and <b>ShipReq qty</b> to <b>{target_qty}</b> and complete the workflow.
                </p>
                """

                html = _house_email_wrap(
                    title="Action Required ‚Äì StarPak Qty Decrease (Reconfirm Job)",
                    intro_html=(
                        "The PolyTex quantity was decreased. PolyTex PO was updated, but StarPak SO/ShipReq must wait for "
                        "StarPak job reconfirmation due to reserved quantity rules."
                    ),
                    body_html=body_html,
                    footer_html="Once the StarPak job is reconfirmed, the workflow will automatically finish the update and release the HOLD.",
                )

                send_email(FULFILLMENT_EMAILS, f"Action Required ‚Äì Qty Decrease (SO {so_num} / Job {job_p2})", html)

                insert_change_log(
                    sqlite_conn,
                    run_id,
                    int(so4_sordernum),
                    1,
                    "FULFILLMENT_DECREASE_EMAIL_SENT",
                    None,
                    float(target_qty),
                    details={"so_num": so_num, "job_p2": job_p2 or ""},
                )

            upsert_order_state(
                sordernum=int(so4_sordernum),
                status="HOLD",
                last_step="P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM",
                last_run_id=run_id,
                last_error_summary=(
                    f"Qty decreased on PT SO. PT PO updated to {requiredqty}. "
                    f"Waiting for StarPak job reconfirm before updating StarPak SO/ShipReq. target_qty={target_qty}"
                ),
                po_p4=po_num,
                so_p2=so_num,
                job_p2=job_p2,
            )

            # Baseline snapshot so we don‚Äôt re-trigger Phase2B on same PV_Req again
            upsert_req_snapshot_keyed(sqlite_conn, str(job_p4), reqgroup, item, requiredqty, requireddate)

            raise WorkflowHold("Phase2B: qty decreased; waiting for StarPak job reconfirm before SO/ShipReq update.")

        # ------------------------------------------------------------
        # ‚úÖ NORMAL FLOW (increase or safe update):
        # Update StarPak SO line qty NOW (uses target_qty)
        # ------------------------------------------------------------
        if abs(so_old_qty - float(target_qty)) <= 0.0001:
            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                1,
                "SO2_NOOP_ALREADY_MATCHED",
                so_old_qty,
                float(target_qty),
                details={"so_num": so_num, "so_linenum": 1},
            )
        else:
            resp_so = update_so_line_qty_api(
                so_num=so_num,
                itemcode=so_itemcode,
                plantcode="2",
                so_linenum=1,
                new_qty=float(target_qty),
                reqdate=so_reqdate,
            )

            # ‚úÖ IMPORTANT: update_so_line_qty_api must return ok=False on real errors
            if not resp_so or resp_so.get("ok") is False:
                insert_change_log(
                    sqlite_conn,
                    run_id,
                    int(so4_sordernum),
                    1,
                    "SO2_UPDATE_FAILED",
                    so_old_qty,
                    float(target_qty),
                    details={
                        "so_num": so_num,
                        "api_entity": resp_so.get("entityName") if isinstance(resp_so, dict) else "XLinkAPISOrder",
                        "api_http_status": resp_so.get("http_status") if isinstance(resp_so, dict) else None,
                        "api_error": resp_so.get("errorMessage") if isinstance(resp_so, dict) else "No response dict",
                        "raw_response": (resp_so.get("raw_response") if isinstance(resp_so, dict) else "") or "",
                    },
                )
                raise WorkflowHold(
                    f"Phase2B: StarPak SO update API failed for SO {so_num} "
                    f"status={resp_so.get('http_status')} err={resp_so.get('errorMessage')}"
                )

            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                1,
                "SO2_UPDATED",
                so_old_qty,
                float(target_qty),
                details={
                    "so_num": so_num,
                    "so_linenum": 1,
                    "api_entity": resp_so.get("entityName"),
                    "api_http_status": resp_so.get("http_status"),
                    "api_error": resp_so.get("errorMessage") or "",
                },
            )
            logger.info(f"Phase2B: StarPak SO {so_num} line 1 updated to {target_qty}.")

            force_starpak_so_authorized(rw_conn, so_num, logger)

        # ------------------------------------------------------------
        # ‚úÖ INCREASE FLOW: Update ShipReq qty immediately after SO update
        # ------------------------------------------------------------
        try:
            st2 = _get_state_fields(sqlite_conn, int(so4_sordernum))
            shipreq_p2 = st2.get("shipreq_p2") if st2 else None
        except Exception:
            shipreq_p2 = None

        if shipreq_p2:
            try:
                from services.polytex_po_update import update_shipreq_line_qty_api
            except Exception:
                update_shipreq_line_qty_api = None

            if update_shipreq_line_qty_api is None:
                raise WorkflowHold("Phase2B (increase): Missing update_shipreq_line_qty_api().")

            resp_sr = update_shipreq_line_qty_api(
                shipreq_num=int(shipreq_p2),
                itemcode=so_itemcode,     # FG itemcode (same as SO line)
                plantcode="2",
                shipreq_linenum=1,
                new_qty=float(target_qty),
                so_num=so_num,
                so_linenum=1,
            )

            if not resp_sr or resp_sr.get("ok") is False:
                raise WorkflowHold(
                    f"Phase2B (increase): ShipReq update failed shipreq={shipreq_p2} "
                    f"status={resp_sr.get('http_status')} err={resp_sr.get('errorMessage')}"
                )

            logger.info(f"Phase2B: ShipReq {shipreq_p2} line 1 updated to {target_qty}.")
        else:
            logger.info(f"Phase2B: No shipreq_p2 stored; skipping ShipReq update for increase. so4={so4_sordernum}")


        # Email fulfillment team (idempotent per target_qty)
        if not _already_logged_change(sqlite_conn, int(so4_sordernum), 1, "FULFILLMENT_COMPLETE_EMAIL_SENT", float(target_qty)):
            body_html = f"""
            <div style="margin:16px 0; padding:14px; border:1px solid #f3f4f6; background:#f9fafb; border-radius:10px;">
            <table style="width:100%; border-collapse:collapse; font-size:14px;">
                <tr><td style="padding:6px 0; width:160px;"><b>StarPak SO:</b></td><td style="padding:6px 0;">{so_num}</td></tr>
                <tr><td style="padding:6px 0;"><b>New Qty:</b></td><td style="padding:6px 0;">{target_qty}</td></tr>
            </table>
            </div>

            <p style="margin:0; font-size:14px; color:#111827;">
            ‚úÖ <b>Next Step:</b> Please reconfirm and COMPLETE this StarPak order manually in Radius.
            </p>
            """

            html = _house_email_wrap(
                title="Action Required ‚Äì StarPak SO Qty Updated",
                intro_html="The automation updated the StarPak Sales Order quantity due to a PolyTex requirement change.",
                body_html=body_html,
                footer_html="Once StarPak reconfirms the job, the workflow will automatically release the HOLD and mark the record COMPLETE.",
            )

            send_email(FULFILLMENT_EMAILS, f"Action Required ‚Äì Complete StarPak SO {so_num}", html)

            insert_change_log(
                sqlite_conn,
                run_id,
                int(so4_sordernum),
                1,
                "FULFILLMENT_COMPLETE_EMAIL_SENT",
                None,
                float(target_qty),
                details={"so_num": so_num},
            )

        upsert_order_state(
            sordernum=int(so4_sordernum),
            status="HOLD",
            last_step="P2_SO_QTY_UPDATED_WAIT_RECONFIRM",
            last_run_id=run_id,
            last_error_summary="StarPak SO qty updated. Fulfillment must reconfirm & COMPLETE the order manually in Radius.",
            po_p4=po_num,
            so_p2=so_num,
            shipreq_p2=shipreq_p2,
        )

        # Update req snapshot baseline for Plant4 now that we processed this req change
        upsert_req_snapshot_keyed(sqlite_conn, str(job_p4), reqgroup, item, requiredqty, requireddate)

        raise WorkflowHold("Phase2B applied: PO + StarPak SO qty updated; waiting for StarPak reconfirm.")

    return any_change


## ---------------------------------------------------------------------
# Phase 2C - Detect StarPak reconfirm and COMPLETE
# Condition: StarPak SO qty == StarPak JOB qty
# ---------------------------------------------------------------------
from services.starpak_so import get_jobline_qty_p2

def detect_starpak_reconfirm_or_complete(sqlite_conn, ro_conn, rw_conn, run_id: str, so4_sordernum: int, logger) -> bool:

    state = _get_state_fields(sqlite_conn, int(so4_sordernum))
    if not state:
        return False

    # ‚úÖ DEBUG LOG - always print what state Phase2C sees
    logger.info(
        f"[Phase2C DEBUG] so4={so4_sordernum} "
        f"last_step={state.get('last_step')} "
        f"status={state.get('status')} "
        f"so_p2={state.get('so_p2')} "
        f"job_p2={state.get('job_p2')}"
    )

    step = str(state.get("last_step") or "")
    if str(state.get("status") or "").upper() != "HOLD":
        return False

    # ‚úÖ Phase2C must ONLY run for StarPak HOLD states
    if step not in (
        "P2_SO_QTY_UPDATED_WAIT_RECONFIRM",
        "P2_SO_QTY_UPDATED_MANUAL_COMPLETE_REQUIRED",
        "P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM",
    ):
        return False

    so_p2 = state.get("so_p2")
    job_p2 = state.get("job_p2")
    shipreq_p2 = state.get("shipreq_p2")

    if not so_p2 or not job_p2:
        logger.info(
            f"Phase2C: Missing so_p2/job_p2 in state for SO4={so4_sordernum}. so_p2={so_p2}, job_p2={job_p2}"
        )
        return False

    so_p2 = int(so_p2)
    job_p2 = str(job_p2)

    # ‚úÖ Derive target_qty from PO ordered qty (source-of-truth)
    target_qty = None
    try:
        m = get_po_map(sqlite_conn, int(so4_sordernum), 1)
        if m:
            po_num = int(m["po_num"])
            po_linenum = int(m["po_linenum"])
            info = get_po_line_info(ro_conn, po_num, po_linenum)
            if info:
                target_qty = float(info.get("orderedqty") or 0.0)
    except Exception as e:
        logger.warning(f"[Phase2C] target_qty derive from PO failed (ignored): {e}")

    # ‚úÖ Read FG item from SO line 1
    so_line = get_so_line_info_p2(ro_conn, so_p2, 1)
    if not so_line:
        logger.info(f"Phase2C: No Plant2 SO lines found for SO={so_p2}.")
        return False

    so_qty = float(so_line.get("OrderedQty") or so_line.get("orderedqty") or 0.0)
    fg_itemcode = str(so_line.get("ItemCode") or so_line.get("itemcode") or "").strip()
    if not fg_itemcode:
        logger.info(f"Phase2C: Could not resolve FG ItemCode from SO={so_p2}.")
        return False

    job_qty = get_jobline_qty_p2(ro_conn, job_p2, fg_itemcode)

    logger.info(
        f"Phase2C CHECK: so4={so4_sordernum} step={step} so2={so_p2} job2={job_p2} "
        f"fg={fg_itemcode} so_qty={so_qty} job_qty={job_qty} target_qty={target_qty}"
    )

    if job_qty is None:
        return False

    # ------------------------------------------------------------
    # ‚úÖ INCREASE HOLD STEP (MISSING IN YOUR CURRENT CODE)
    # Wait until StarPak reconfirm makes job_qty == target_qty
    # ------------------------------------------------------------
    if step == "P2_SO_QTY_UPDATED_WAIT_RECONFIRM":
        if target_qty is None:
            logger.info("[Phase2C] Increase flow: target_qty not available yet; keep HOLD.")
            return False

        if abs(float(job_qty) - float(target_qty)) > 0.0001:
            upsert_order_state(
                sordernum=int(so4_sordernum),
                status="HOLD",
                last_step="P2_SO_QTY_UPDATED_WAIT_RECONFIRM",
                last_run_id=run_id,
                last_error_summary=f"Waiting StarPak reconfirm (increase): Job qty={job_qty}, target={target_qty}",
                so_p2=so_p2,
                job_p2=job_p2,
                shipreq_p2=shipreq_p2,
            )
            logger.info(
                f"Phase2C: SO {so4_sordernum} still waiting for StarPak reconfirm "
                f"(job_qty={job_qty}, target_qty={target_qty})."
            )
            return False

        # ‚úÖ reconfirm satisfied -> COMPLETE
        upsert_order_state(
            sordernum=int(so4_sordernum),
            status="COMPLETE",
            last_step="COMPLETE",
            last_run_id=run_id,
            last_error_summary=f"Phase2C: Increase complete (job_qty == target_qty == {target_qty}).",
        )
        insert_change_log(
            sqlite_conn,
            run_id,
            int(so4_sordernum),
            0,
            "P2_INCREASE_COMPLETE_RELEASED",
            None,
            float(target_qty),
            details={"job_p2": job_p2, "so_p2": so_p2, "shipreq_p2": shipreq_p2 or "", "fg_itemcode": fg_itemcode},
        )

        # ‚úÖ Refresh snapshot baseline ONLY on COMPLETE (not while waiting)
        try:
            so4_lines = get_so_lines_p4(ro_conn, int(so4_sordernum))
            for ln in so4_lines:
                line_num = int(ln.get("SOrderLineNum") or ln.get("sorderlinenum") or 0)
                itemcode = str(ln.get("ItemCode") or ln.get("itemcode") or "").strip()
                orderedqty = float(ln.get("OrderedQty") or ln.get("orderedqty") or 0.0)
                reqdate = str(ln.get("ReqDate") or ln.get("reqdate") or "")[:10]
                if line_num:
                    upsert_so4_line_snapshot(sqlite_conn, int(so4_sordernum), int(line_num), itemcode, orderedqty, reqdate)
            logger.info(f"Phase2C: refreshed SO4 snapshot baseline for SO {so4_sordernum}")
        except Exception as e:
            logger.warning(f"Phase2C: failed to refresh SO4 snapshot baseline (ignored): {e}")

        logger.info(f"Phase2C: SO {so4_sordernum} released to COMPLETE (increase reconfirm detected).")
        return True

    # ------------------------------------------------------------
    # ‚úÖ DECREASE HOLD STEP:
    # Wait until StarPak reconfirm results in job_qty == target_qty,
    # then update SO qty + ShipReq qty and finish.
    # ------------------------------------------------------------
    if step == "P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM":
        if target_qty is None:
            logger.info("[Phase2C] Decrease flow: target_qty not available yet; keep HOLD.")
            return False

        if abs(float(job_qty) - float(target_qty)) > 0.0001:
            upsert_order_state(
                sordernum=int(so4_sordernum),
                status="HOLD",
                last_step="P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM",
                last_run_id=run_id,
                last_error_summary=f"Waiting StarPak job reconfirm (decrease): Job qty={job_qty}, target={target_qty}",
                so_p2=so_p2,
                job_p2=job_p2,
                shipreq_p2=shipreq_p2,
            )
            return False

        # ‚úÖ Reconfirm satisfied. Now ensure SO + ShipReq match target_qty.
        so_needs_update = abs(float(so_qty) - float(target_qty)) > 0.0001

        if so_needs_update:
            resp_so = update_so_line_qty_api(
                so_num=so_p2,
                itemcode=fg_itemcode,
                plantcode="2",
                so_linenum=1,
                new_qty=float(target_qty),
                reqdate=str(so_line.get("ReqDate") or so_line.get("reqdate") or "")[:10],
            )
            if not resp_so or resp_so.get("ok") is False:
                upsert_order_state(
                    sordernum=int(so4_sordernum),
                    status="HOLD",
                    last_step="P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM",
                    last_run_id=run_id,
                    last_error_summary=f"Phase2C (decrease): SO update failed; will retry. so2={so_p2} target={target_qty}",
                    so_p2=so_p2,
                    job_p2=job_p2,
                    shipreq_p2=shipreq_p2,
                )
                raise WorkflowHold(
                    f"Phase2C (decrease): StarPak SO update failed so2={so_p2} "
                    f"status={resp_so.get('http_status')} err={resp_so.get('errorMessage')}"
                )
        else:
            logger.info(
                f"[Phase2C] Decrease flow: SO already at target; skipping SO update. "
                f"so2={so_p2} so_qty={so_qty} target_qty={target_qty}"
            )

        if shipreq_p2:
            try:
                from services.polytex_po_update import update_shipreq_line_qty_api
            except Exception:
                update_shipreq_line_qty_api = None

            if update_shipreq_line_qty_api is None:
                upsert_order_state(
                    sordernum=int(so4_sordernum),
                    status="HOLD",
                    last_step="P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM",
                    last_run_id=run_id,
                    last_error_summary="Phase2C (decrease): Missing update_shipreq_line_qty_api; cannot update ShipReq.",
                    so_p2=so_p2,
                    job_p2=job_p2,
                    shipreq_p2=shipreq_p2,
                )
                raise WorkflowHold("Phase2C (decrease): Missing update_shipreq_line_qty_api().")

            resp_sr = update_shipreq_line_qty_api(
                shipreq_num=int(shipreq_p2),
                itemcode=fg_itemcode,
                plantcode="2",
                shipreq_linenum=1,
                new_qty=float(target_qty),
                so_num=so_p2,
                so_linenum=1,
            )
            if not resp_sr or resp_sr.get("ok") is False:
                upsert_order_state(
                    sordernum=int(so4_sordernum),
                    status="HOLD",
                    last_step="P2_QTY_DECREASE_WAIT_SP_JOB_RECONFIRM",
                    last_run_id=run_id,
                    last_error_summary=f"Phase2C (decrease): ShipReq update failed; will retry. shipreq={shipreq_p2} target={target_qty}",
                    so_p2=so_p2,
                    job_p2=job_p2,
                    shipreq_p2=shipreq_p2,
                )
                raise WorkflowHold(
                    f"Phase2C (decrease): ShipReq update failed shipreq={shipreq_p2} "
                    f"status={resp_sr.get('http_status')} err={resp_sr.get('errorMessage')}"
                )

        force_starpak_so_authorized(rw_conn, so_p2, logger)

        upsert_order_state(
            sordernum=int(so4_sordernum),
            status="COMPLETE",
            last_step="COMPLETE",
            last_run_id=run_id,
            last_error_summary=f"Phase2C: Decrease complete (job reconfirm detected, SO/ShipReq updated to {target_qty}).",
        )
        insert_change_log(
            sqlite_conn,
            run_id,
            int(so4_sordernum),
            0,
            "P2_DECREASE_COMPLETE_RELEASED",
            None,
            float(target_qty),
            details={"job_p2": job_p2, "so_p2": so_p2, "shipreq_p2": shipreq_p2 or "", "fg_itemcode": fg_itemcode},
        )

        # ‚úÖ Refresh snapshot baseline ONLY on COMPLETE
        try:
            so4_lines = get_so_lines_p4(ro_conn, int(so4_sordernum))
            for ln in so4_lines:
                line_num = int(ln.get("SOrderLineNum") or ln.get("sorderlinenum") or 0)
                itemcode = str(ln.get("ItemCode") or ln.get("itemcode") or "").strip()
                orderedqty = float(ln.get("OrderedQty") or ln.get("orderedqty") or 0.0)
                reqdate = str(ln.get("ReqDate") or ln.get("reqdate") or "")[:10]
                if line_num:
                    upsert_so4_line_snapshot(sqlite_conn, int(so4_sordernum), int(line_num), itemcode, orderedqty, reqdate)
            logger.info(f"Phase2C: refreshed SO4 snapshot baseline for SO {so4_sordernum}")
        except Exception as e:
            logger.warning(f"Phase2C: failed to refresh SO4 snapshot baseline (ignored): {e}")

        logger.info(f"Phase2C: SO {so4_sordernum} released to COMPLETE (decrease reconfirm detected).")
        return True

    # ------------------------------------------------------------
    # ‚úÖ Any other HOLD step (including manual required):
    # Do NOT auto-complete.
    # ------------------------------------------------------------
    logger.info(
        f"Phase2C: SO {so4_sordernum} still waiting (step={step}) "
        f"(job_qty={job_qty}, target_qty={target_qty})."
    )
    return False
